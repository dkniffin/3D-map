var container;
var camera, controls, scene, renderer;
var mesh, texture;

var SRTMData;

var worldWidth = 256, worldDepth = 256,
worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

var clock = new THREE.Clock();

function init(){
	container = document.getElementById('mapContainer');

	// Create the scene
	scene = new THREE.Scene();

	// Create the camera
	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 20000 );

	// Set up controls
	controls = new THREE.FirstPersonControls( camera );
	controls.movementSpeed = 1000;
	controls.lookSpeed = 0.1;


	// Generate the height data
	//data = generateHeight( worldWidth, worldDepth );

	

	// Generate a PlaneGeometry object with the data generated above
	var geometry = new THREE.PlaneGeometry( 7500, 7500, worldWidth - 1, worldDepth - 1 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	populateDataIntoGeometry(SRTMData, geometry, .01);

	console.log('geometry:');
	console.log(geometry);

	// Position the camera
	var mid = dataMiddle(SRTMData);
	camera.position.x = mid[0];
	camera.position.y = mid[1];
	camera.position.z = mid[2];

	// Create a texture
	//texture = new THREE.Texture( generateTexture( data, worldWidth, worldDepth ), new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping );
	texture = new THREE.ImageUtils.loadTexture('crate.gif'),
	texture.needsUpdate = true;

	// Create a mesh out of the geometry and the texture
	mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
	scene.add( mesh );


	// Initialize the Renderer
	if (window.WebGLRenderingContext)
		renderer = new THREE.WebGLRenderer();
	else
		renderer = new THREE.CanvasRenderer();
	renderer.setSize( window.innerWidth, window.innerHeight );

	// Empty the rendering container
	container.innerHTML = "";

	// Append the renderer to the container
	container.appendChild( renderer.domElement );

	// Set up a window resize listener
	window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize() {
	// On window resize, update aspect ratio

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

	controls.handleResize();

}

function generateHeight( width, height ) {
	// Generate the height for the terrain.

	var size = width * height, data = new Float32Array( size );
	perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

	for ( var i = 0; i < size; i++ ) {

		data[ i ] = 0;

	}

	for ( var j = 0; j < 4; j ++ ) {

		for ( var i = 0; i < size; i ++ ) {

			var x = i % width, y = ~~ ( i / width );
			data[i] = (i % 2)*10;
			data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

		}
		quality *= 5;
	}
	return data;


}

function populateDataIntoGeometry(inData, geometry, precision) {
	// The precision defines how precise the data should be 
	// (ie: the distance between "height points"). By inverting 
	// it, we get the number of division that should be made to 
	// the area.
	// eg: if we are given a precision of '.1' (meaning .1 degree),
	// then we should divide each 'degree' of lat and lon into 10 
	// pieces, thus creating points at which the height is defined
	var numDivisions = (1/precision);
	
	/* data interpolation algorithm */

	// Create an incrementer for the geometry vertices, which 
	// will be a one dimensional array
	var vindex = 0; 

	var cachedEle = 0;
	// Loop from minLat->maxLat, incrementing by precision
	for (var lat = inData.minLat; lat <= inData.maxLat; lat += precision) {
		// Loop from minLon->maxLon, incrementing by precision
		for (var lon = inData.minLon; lon <= inData.maxLon; lon += precision) {
			if (typeof inData['nodes'][lat] != 'undefined'){
				if (typeof inData['nodes'][lat][lon] != 'undefined'){
					cachedEle = inData['nodes'][lat][lon];
				}
			}
			// Add a new entry to data for that point
			geometry.vertices[vindex].x = lat;
			geometry.vertices[vindex].y = lon;
			geometry.vertices[vindex].z = cachedEle;
		}
	}
}

function dataMiddle(inData){
	var midLat = (inData.maxLat + inData.minLat)/2;
	var midLon = (inData.maxLon + inData.minLon)/2;
	var midEle = (inData.maxEle + inData.minEle)/2;
	return [midLat,midLon,midEle];
}

function populateSRTMData(data){
	SRTMData = data;
}

function generateTexture( data, width, height ) {

	var canvas, canvasScaled, context, image, imageData,
	level, diff, vector3, sun, shade;

	vector3 = new THREE.Vector3( 0, 0, 0 );

	sun = new THREE.Vector3( 1, 1, 1 );
	sun.normalize();

	canvas = document.createElement( 'canvas' );
	canvas.width = width;
	canvas.height = height;

	context = canvas.getContext( '2d' );
	context.fillStyle = '#000';
	context.fillRect( 0, 0, width, height );

	image = context.getImageData( 0, 0, canvas.width, canvas.height );
	imageData = image.data;

	for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

		vector3.x = data[ j - 2 ] - data[ j + 2 ];
		vector3.y = 2;
		vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
		vector3.normalize();

		shade = vector3.dot( sun );

		imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
		imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
		imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
	}

	context.putImageData( image, 0, 0 );

	// Scaled 4x

	canvasScaled = document.createElement( 'canvas' );
	canvasScaled.width = width * 4;
	canvasScaled.height = height * 4;

	context = canvasScaled.getContext( '2d' );
	context.scale( 4, 4 );
	context.drawImage( canvas, 0, 0 );

	image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
	imageData = image.data;

	for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

		var v = ~~ ( Math.random() * 5 );

		imageData[ i ] += v;
		imageData[ i + 1 ] += v;
		imageData[ i + 2 ] += v;

	}

	context.putImageData( image, 0, 0 );

	return canvasScaled;

}

function animate() {

	requestAnimationFrame( animate );

	render();

}

function render() {

	controls.update( clock.getDelta() );
	renderer.render( scene, camera );

}
